// AUDIT-GRADE PRISMA SCHEMA
// Compréhension pour débutant: ce fichier définit la base de données.
// - User: comptes utilisateurs
// - Listing: objets vendus
// - PaymentIntent: intention de paiement (workflow)
// - Account & LedgerEntry: comptabilité en double écriture
// - IdempotencyKey: protection anti-rejeu (mêmes requêtes => même résultat)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  USER
  SELLER
  ADMIN
}

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
  NONE
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  emailVerified Boolean @default(false)
  phone     String?  @unique
  phoneVerified Boolean @default(false)
  password  String
  resetToken String?
  resetTokenExpiry DateTime?
  role      Role     @default(USER)
  kycStatus KycStatus @default(NONE)
  isBlocked Boolean   @default(false)
  createdAt DateTime @default(now())
  accounts  Account[]
  intentsBought PaymentIntent[] @relation("IntentBuyer")
  intentsSold   PaymentIntent[] @relation("IntentSeller")
  listings      Listing[]
  buyerConversations Conversation[] @relation("BuyerConversations")
  sellerConversations Conversation[] @relation("SellerConversations")
  sentMessages      Message[]       @relation("SentMessages")
  givenReviews      Review[]        @relation("GivenReviews")
  receivedReviews   Review[]        @relation("ReceivedReviews")
}

enum ListingStatus {
  ACTIVE
  SOLD
  INACTIVE
}

model Listing {
  id        String   @id @default(uuid())
  title     String
  description String?
  priceCfa  Int
  images    String[]
  size      String?
  brand     String?
  condition String?
  status    ListingStatus @default(ACTIVE)
  sellerId  String
  seller    User     @relation(fields: [sellerId], references: [id])
  intents   PaymentIntent[]
  conversations Conversation[]
  reviews       Review[]
  createdAt DateTime @default(now())
}

enum PaymentIntentStatus {
  REQUIRES_CONFIRMATION
  CONFIRMED
  CAPTURED
  REFUNDED
  CANCELED
}

model PaymentIntent {
  id         String               @id @default(uuid())
  listingId  String
  listing    Listing              @relation(fields: [listingId], references: [id])
  buyerId    String
  buyer      User                 @relation("IntentBuyer", fields: [buyerId], references: [id])
  sellerId   String
  seller     User                 @relation("IntentSeller", fields: [sellerId], references: [id])
  amountCfa  Int
  feeCfa     Int
  status     PaymentIntentStatus  @default(REQUIRES_CONFIRMATION)
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt
  idempotencyKey String?          @unique
  ledgerEntries LedgerEntry[]
}

enum AccountType {
  USER
  PLATFORM_ESCROW
  PLATFORM_FEES
  EXTERNAL_PSP
}

model Account {
  id        String      @id @default(uuid())
  type      AccountType
  userId    String?
  user      User?       @relation(fields: [userId], references: [id])
  currency  String      @default("XOF")
  createdAt DateTime    @default(now())
  entries   LedgerEntry[]
}

model LedgerEntry {
  id        String        @id @default(uuid())
  accountId String
  account   Account       @relation(fields: [accountId], references: [id])
  intentId  String?
  intent    PaymentIntent? @relation(fields: [intentId], references: [id])
  deltaCfa  Int
  desc      String?
  createdAt DateTime      @default(now())
}

model IdempotencyKey {
  id           String   @id @default(uuid())
  key          String   @unique
  method       String
  path         String
  requestHash  String
  statusCode   Int?
  responseBody Json?
  createdAt    DateTime @default(now())
  lockedAt     DateTime?
  completedAt  DateTime?
}

model Conversation {
  id        String   @id @default(uuid())
  listingId String?
  listing   Listing? @relation(fields: [listingId], references: [id])
  buyerId   String
  buyer     User     @relation("BuyerConversations", fields: [buyerId], references: [id])
  sellerId  String
  seller    User     @relation("SellerConversations", fields: [sellerId], references: [id])
  messages  Message[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  senderId       String
  sender         User         @relation("SentMessages", fields: [senderId], references: [id])
  content        String
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())
}

model Review {
  id        String   @id @default(uuid())
  reviewerId String
  reviewer   User     @relation("GivenReviews", fields: [reviewerId], references: [id])
  targetId   String
  target     User     @relation("ReceivedReviews", fields: [targetId], references: [id])
  listingId  String?
  listing    Listing? @relation(fields: [listingId], references: [id])
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())
}
